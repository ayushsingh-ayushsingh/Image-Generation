const { Builder, By, Key, until } = require('selenium-webdriver');
const chrome = require('selenium-webdriver/chrome');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

let counter = 1;
let text = "serene landscape at sunrise, with a calm lake reflecting the pink and orange hues of the sky, surrounded by lush green forests and distant mountains shrouded in mist.";

let CFG = 3.5;
let steps = 28;
let outputQuality = 90;
let promptStrength = 0.85;

// 1:1, 16:9, 21:9, 3:2, 5:4
let aspect_ratio = "3:2";
let inputImage = "";
let outputFormat = "webp";
let seed = "";

const LIMIT = 5;
const folder = "autogenerated";
const MAX_RETRIES = 3;
const RETRY_DELAY = 5000;

const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function generateAiArt() {
    while (counter <= LIMIT) {
        let retries = 0;
        while (retries < MAX_RETRIES) {
            let driver;
            try {
                console.log(`Attempt ${retries + 1} for image ${counter}`);
                console.log("Image generation is in progress...");
                
                let options = new chrome.Options();
                options.addArguments(
                    "--no-sandbox",
                    "--disable-dev-shm-usage",
                    "--disable-gpu",
                    "--disable-extensions",
                    "--disable-software-rasterizer",
                    "--headless",
                    "--window-size=1920,1080"
                );

                driver = await new Builder()
                    .forBrowser('chrome')
                    .setChromeOptions(options)
                    .build();

                await driver.get('https://replicate.com/stability-ai/stable-diffusion-3?prediction=jrdt4zf9anrm00cgeecvs7fhbr');

                let inputArea = await driver.wait(until.elementLocated(By.id('prompt')), 10000);
                await inputArea.clear();
                await inputArea.sendKeys(text);

                let aspectRatioSelect = await driver.findElement(By.id('aspect_ratio'));
                await aspectRatioSelect.findElement(By.css(`option[value="${aspect_ratio}"]`)).click();

                let cfgInput = await driver.findElement(By.id('cfg'));
                await cfgInput.clear();
                await cfgInput.sendKeys(CFG.toString());

                if (inputImage) {
                    let imageInput = await driver.findElement(By.id('image'));
                    await imageInput.sendKeys(inputImage);
                }

                let promptStrengthInput = await driver.findElement(By.id('prompt_strength'));
                await promptStrengthInput.clear();
                await promptStrengthInput.sendKeys(promptStrength.toString());

                let stepsInput = await driver.findElement(By.id('steps'));
                await stepsInput.clear();
                await stepsInput.sendKeys(steps.toString());

                let outputFormatSelect = await driver.findElement(By.id('output_format'));
                await outputFormatSelect.findElement(By.css(`option[value="${outputFormat}"]`)).click();

                let outputQualityInput = await driver.findElement(By.id('output_quality'));
                await outputQualityInput.clear();
                await outputQualityInput.sendKeys(outputQuality.toString());

                if (seed) {
                    let seedInput = await driver.findElement(By.id('seed'));
                    await seedInput.clear();
                    await seedInput.sendKeys(seed.toString());
                }

                await driver.actions()
                    .keyDown(Key.CONTROL)
                    .sendKeys(Key.RETURN)
                    .keyUp(Key.CONTROL)
                    .perform();

                let imageElement = await driver.wait(until.elementLocated(By.xpath("//img[@data-testid='value-output-image']")), 60000);

                let imageUrl = await imageElement.getAttribute('src');
                let response = await axios.get(imageUrl, { responseType: 'arraybuffer' });

                fs.writeFileSync(`image.${outputFormat}`, response.data);
                const dir = `./${folder}`;
                if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir);
                }

                const filePath = path.join(dir, `${counter}.${outputFormat}`);
                fs.writeFileSync(filePath, response.data);
                console.log(`Image saved as '${filePath}'`);
                
                counter++;
                break;
            } catch (error) {
                console.error(`Error occurred: ${error.message}`);
                retries++;
                if (retries >= MAX_RETRIES) {
                    console.log(`Failed to generate image after ${MAX_RETRIES} attempts. Moving to next image.`);
                    counter++;
                } else {
                    console.log(`Retrying in ${RETRY_DELAY / 1000} seconds...`);
                    await delay(RETRY_DELAY);
                }
            } finally {
                if (driver) {
                    await driver.quit().catch(console.error);
                }
            }
        }
    }
    console.log(`Reached the limit of ${LIMIT} images. Stopping.`);
}

generateAiArt();
